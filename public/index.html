<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />       
    <title>React Template</title>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=8078c85810051d852b357da4a8be72e2"></script>  
    <style>
      .default {
        position: absolute; top: -99999px;
      }
      .mask {
        width: 100%; height: 100vh; background: #000; position: fixed; top: 0px; left: 0px; z-index: 100;
        transition: opacity 2s; display: flex; justify-content: center; align-items: center; 
        font: 18px/1 'arial'; color: #fff; 
      }
      .mask.off {
        opacity: 0;
      }
    </style>  
  </head>
  <body>    
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>      
    <div class="default"></div>  
    <div class="mask">LOADING...</div> 
    
    <script>
      //캐싱할 이미지 주소를 배열로 저장
      const imgs = [
        'https://react2022.github.io/react_feb/img/bg1.jpg',
        'https://react2022.github.io/react_feb/img/bg2.jpg',
        'https://react2022.github.io/react_feb/img/bg3.jpg',
        'https://react2022.github.io/react_feb/img/bg4.jpg',
        'https://react2022.github.io/react_feb/img/bg5.jpg',
      ];

      const vids = [
        'https://react2022.github.io/react_feb/img/vid1.mp4',
        'https://react2022.github.io/react_feb/img/vid2.mp4',
      ];

      //이미지주소 갯수, default, maskDOM 캐싱
      const lenImg = imgs.length;
      const lenVid = vids.length;
      const defaults = document.querySelector('.default');
      const mask = document.querySelector('.mask');
      let tags = '';
      
      //배열을 반복돌면서 동적으로 imgDOM생성
      imgs.forEach(src=>{
        tags+=`<img src=${src} />`;
      });

      //배열을 반복돌면서 동적으로 vidDOM생성
      vids.forEach(src=>{
        tags+=`<video src=${src} />`;
      }); 

      defaults.innerHTML = tags;


      //모든 이미지 소스가 완료되면 loadedaImg에 true값 할당
      const imgDOM = defaults.querySelectorAll('img');
      let countImg = 0;
      let loadedImg = false; 
      
      imgDOM.forEach(img => {
        img.onload = () =>{
          countImg++;         
          if(countImg === lenImg) loadedImg  = true; 
        }
      });

      //모든 동영상 소스가 완료되면 loadedVid에 true값 할당
      const vidDOM = defaults.querySelectorAll('video');
      let countVid = 0;
      let loadedVid = false;
      
      vidDOM.forEach(vid => {
        vid.onloadeddata = () =>{
          countVid++;
          if(countVid === lenVid) loadedVid = true;
        }
      });

      //loadedImg와 loadedVid값 모두 true명 default, mask제거
      if(loadedImg && loadedVid){
        defaults.remove();
        mask.classList.add('off');
        setTimeout(()=> mask.remove(), 2000);
      }
    </script>
  </body>
</html>

<!-- 
  SSR (Server Side Rendering)
  --서버쪽에서 데이터를 받아 브라우저 화면을 출력
  --HTML방식 (MPA)
  --장점 - 초기 로딩속도가 빠름
  --단점 - 페이지이동할때마다 서버쪽에 각각의 HTML파일 데이터를 불러와야 되기 때문에 페이지 이동시 UX가 안좋음

  CSR (Client Side Renderging)
  -- 서버쪽에 모든 서브페이지까지 포함한 컴포넌트를 한번에 불러옴 
  -- SPA
  -- 단점 - index.html에 동적으로 넣어줄 데이터를 나중에 적용하기 때문에 SEO, 초기로딩속도 김
  -- 장점 - 페이지 전환시 비동기적으로 라우터를 이용해서 새로 렌더링이 필요한 컴포넌트만 바꿔치기


  NEXT.js (Framework)
  위와 같은 SSR, CSR의 단점들을 서로 보완하기 위해서 초기화면 로딩시에는 SSR방식으로
  그 이후 라우터 이동시에는 기존의 CSR방식으로 개발하게 도와주는 프레임워크 (검색엔진 최적화)

  TypeScript
  - 기존 자바스크립트 자료형에 따라서 변수선언시 일일이 타입을 지정하는 형태
  - 웹팩, 바벨을 이용해서 한번 컴파일 과정을 거침
  - 컴파일 과정에서 잠재적으로 발생할 수 있는 오류를 미리 걸러줌
  - 실제 서비스 운영사 런타임 오류를 최소화

 -->
